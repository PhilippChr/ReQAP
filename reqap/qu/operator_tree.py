from typing import Dict, List, Optional, Tuple

from reqap.classes.qu_execution_res import QUExecutionResult


class OperatorTree:
    """
    Operator Tree is a single and specified plan of function calls.
    The Operator Tree is generated by the QU module, and derived from
    a QU tree, which can have multiple Operator Trees.
    """
    def __init__(self, operator_tree_dict: Dict):
        self.qu_branch_input = operator_tree_dict["qu_branch_input"]  # previous call (for connection)
        self.qu_input = operator_tree_dict["qu_input"]  # current call
        self.childs: List[OperatorTree] = [OperatorTree(c_dict) for c_dict in operator_tree_dict["childs"]]
        self.execution_result: Optional[QUExecutionResult] = None

    @classmethod
    def from_operator_tree_dicts(cls, operator_tree_dicts: List[Dict]) -> List["OperatorTree"]:
        """
        Load multiple QUPlan objects from a list of QUPlan dicts,
        with keys `qu_branch_input`, `qu_input`, and `childs`.
        Used to load Operator trees after stored via `to_dict`.
        """
        return [cls(operator_tree_dict) for operator_tree_dict in operator_tree_dicts]

    @classmethod
    def from_operator_tree_dict(cls, operator_tree_dict: Dict) -> "OperatorTree":
        """
        Load a single QUPlan object from a QUPlan dict,
        with keys `qu_branch_input`, `qu_input`, and `childs`.
        Used to load a QUPlan after stored via `to_dict`.
        """
        return cls(operator_tree_dict)
    
    @classmethod
    def from_list(cls, operator_tree_list: List[Dict]) -> "OperatorTree":
        """
        Load a single QUPlan object from a list of dicts with keys `qu_input` and `operator_tree`.
        Used to check ICL example data.
        """
        def dict_from_list(operator_tree_list: List[Dict]) -> Dict:
            # childs have to be processed to a Dict
            qu_input = operator_tree_list[0]["qu_input"]
            qu_output = operator_tree_list[0]["operator_tree"]
            child_indices = [i for i, it in enumerate(operator_tree_list) if "{{ " + it["qu_input"] + " }}" in qu_output]
            childs = [
                dict_from_list(operator_tree_list[i:])
                for i in child_indices
            ]
            operator_tree_dict = {
                "qu_branch_input": qu_input,
                "qu_input": qu_output,
                "childs": childs
            }
            return operator_tree_dict

        qu_input = operator_tree_list[0]["qu_input"]
        childs = [dict_from_list(operator_tree_list)]
        qu_input = "{{ " + qu_input + " }}"
            
        # construct QUPlan
        operator_tree_dict = {
            "qu_branch_input": None,
            "qu_input": qu_input,
            "childs": childs
        }
        return cls(operator_tree_dict)
    
    def to_list(self, operator_tree_list: List[Dict]=list()) -> List[Dict]:
        if not self.qu_branch_input is None:
            operator_tree_list.append({
                "qu_input": self.qu_branch_input,
                "operator_tree": self.qu_input
            })
        for child in self.childs:
            child.to_list(operator_tree_list)
        return operator_tree_list

    def to_dict(self) -> Dict:
        d = {
            "qu_branch_input": self.qu_branch_input,
            "qu_input": self.qu_input,
            "childs": [c.to_dict() for c in self.childs]
        }
        if self.execution_result is not None:
            d["execution_result"] = self.execution_result.to_dict()
            self.reduce_size(d["execution_result"])
        return d
    
    @staticmethod
    def reduce_size(exec_res, max_num_events=1000, max_result_length=1000):
        def _reduce_items(items):
            items = items[:max_num_events]
            for item in items:
                # for groups
                if "computed_items" in item:
                    item["computed_items"] = _reduce_items(item["computed_items"])
                # for joined items (overlap, join, ...)
                elif "observable_events" in item:
                    item["observable_events"] = _reduce_items(item["observable_events"])
            return items
        if "computed_items" in exec_res:
            exec_res["num_computed_items"] = len(exec_res["computed_items"])
            exec_res["computed_items"] = _reduce_items(exec_res["computed_items"])
        elif "groups" in exec_res:
            exec_res["num_computed_items"] = len(exec_res["groups"])
            exec_res["groups"] = _reduce_items(exec_res["groups"])
        if "result" in exec_res:
            exec_res["result"] = exec_res["result"][:max_result_length]
    
    """
    Functions for plan execution.
    """
    def get_next_unprocessed_node(self) -> Optional["OperatorTree"]:
        """
        Searches the tree for the next unprocessed node via recursive calls.
        Processes the tree in depth-first mode.
        Returns the node (=QUPlan) which needs to be processed next,
        or None in case the whole plan is processed already.
        Make sure to run this function from the root node.
        """
        for child in self.childs:
            node = child.get_next_unprocessed_node()
            if node is not None:
                return node
        if self.execution_result is None:
            return self
        return None
    
    def set_execution_result(self, exec_result: QUExecutionResult) -> None:
        self.execution_result = exec_result

    def get_child_execution_results(self) -> Dict[str, QUExecutionResult]:
        exec_results = dict()
        for child in self.childs:
            exec_results[child.qu_branch_input] = child.execution_result
        return exec_results
    
    def get_cache_key(self) -> str:
        SEPARATOR = ", "
        key = self.qu_input
        child_keys = SEPARATOR.join(child.get_cache_key() for child in self.childs)
        cache_key = f"{key}{SEPARATOR}{child_keys}"
        return cache_key

    """
    Functions for deriving training data.
    """
    def get_retrieve_calls(self) -> List[str]:
        """ Used for training RETRIEVE module. """
        return self._get_retrieve_calls(self.to_dict())

    def _get_retrieve_calls(self, sub_dict: Dict) -> List[str]:
        retrieve_calls = list()
        if sub_dict["qu_input"].startswith("RETRIEVE"):
            retrieve_calls.append(sub_dict["qu_input"])
        for child in sub_dict["childs"]:
            retrieve_calls += self._get_retrieve_calls(child)
        return retrieve_calls

    def get_extract_calls(self) -> List[str]:
        """ Used for training EXTRACT module. """
        return self._get_extract_calls(self.to_dict())

    def _get_extract_calls(self, sub_dict: Dict) -> List[str]:
        extract_calls = list()
        if sub_dict["qu_input"].startswith("SELECT"):
            extract_calls.append(sub_dict["qu_input"])
        for child in sub_dict["childs"]:
            extract_calls += self._get_extract_calls(child)
        return extract_calls
    
    def derive_training_data(self, parents: List[str] = list()) -> Tuple[List[str], List[str]]:
        """ Used for training QU module. """
        inputs = list()
        outputs = list()
        
        # add current branch as input
        if self.qu_branch_input:
            parents.append((self.qu_branch_input, self.qu_input))
            inputs.append(parents)
            outputs.append(self.qu_input)
        
        # add childs
        child_parents = parents.copy()
        for child in self.childs:
            new_inputs, new_outputs = child.derive_training_data(parents=child_parents)
            inputs += new_inputs
            outputs += new_outputs
        return inputs, outputs
    
    @staticmethod
    def derive_full_operator_tree(d: Dict, transformation_dict=dict()) -> str:
        # derive mapping from below
        for child in d["childs"]:
            OperatorTree.derive_full_operator_tree(child, transformation_dict)
        
        # transform current call
        qu_input = d["qu_input"]
        for key, val in transformation_dict.items():
            qu_input = qu_input.replace(key, val)
        
        # add to transformation dict
        if not d["qu_branch_input"] is None:
            qu_branch_input = "{{ " + d["qu_branch_input"] + " }}"
            transformation_dict[qu_branch_input] = qu_input
        
        # return result (only relevant for last call)
        return qu_input

    def derive_representation(self) -> str:
        """
        Derive a string representation of the Operator Tree to identify isomorph graphs.
        """
        # derive operator for present node
        operator = self.qu_input.split("(", 1)[0]
        operator = operator.replace("{", "").replace("}", "")
        
        # derive child operators (+ sort for isomorphism check)
        child_operators = sorted([c.derive_representation() for c in self.childs])
        child_args = ", ".join(child_operators)
        return f"{operator}({child_args})".strip()
